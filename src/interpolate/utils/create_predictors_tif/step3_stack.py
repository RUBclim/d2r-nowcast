"""
Stack predictors into a single raster file.
"""

import json
from pathlib import Path

import numpy as np
import rasterio as rio
from sklearn.decomposition import PCA
from sklearn.preprocessing import RobustScaler

# Add the name of the predictors you want to stack
# The predictors are the names of the files in the
# folder generated by step2_prepare.py.
PREDICTORS = [
    "BDSM2_mean_L1",
    "BDSM2_stdev_L1",
    "BU_perc_L1",
    "DTM_mean_L1",
    "DTM_stdev_L1",
    "VEG_perc_L1",
    "VEG_mean_L1",
    "COLD_perc_L1",
    "ROAD_perc_L1",
    "SVF_mean_L1",
    "CLMT1_perc_L1",
    "CLMT2_perc_L1",
    "CLMT3_perc_L1",
    "CLMT4_perc_L1",
    "CLMT5_perc_L1",
    "CLMT6_perc_L1",
    "CLMT7_perc_L1",
    "CLMT8_perc_L1",
    "IND_perc_L1",
    "BUAREA_mean_L1",
    "BUAREA_stdev_L1",
]


QMIN = 0
QMAX = 100
FILL_VALUE = -32768


def read_raster(path, fname):
    """Read and clip a raster to the study area bounds"""
    with rio.open(path / fname) as ds:
        data = ds.read()
        tf = ds.transform
        crs = ds.crs
    return data.astype(np.float32), tf, crs


def apply_mask(array, mask):
    """Mask an array"""
    mask = np.broadcast_to(mask, array.shape)
    array[np.isnan(array)] = FILL_VALUE
    array[mask != 1] = FILL_VALUE
    return np.ma.masked_equal(array, FILL_VALUE)


def create_lonlat_grids(transform, width, height):
    """Create an array with the longitude and latitude of each pixel"""
    left = transform.c
    top = transform.f
    right = left + width * transform.a
    bottom = top + height * transform.e
    lons = np.linspace(left, right, width)
    lats = np.linspace(top, bottom, height)
    return np.meshgrid(lons, lats, indexing="xy")


def robust_scaler(array):
    """Rescale array to [-1, 1] using the QMIN and QMAX quantiles"""
    bands, height, width = array.shape

    mask = array.mask
    out = np.empty(shape=(bands, height, width), dtype=np.float32)

    for i, arr in enumerate(array):
        tf = RobustScaler(quantile_range=(QMIN, QMAX))
        tf.fit(arr.compressed().reshape(-1, 1))
        out[i, :, :] = tf.transform(arr.reshape(-1, 1)).reshape(1, height, width)

    out[mask] = FILL_VALUE
    return np.ma.masked_equal(out, FILL_VALUE)


def stack_predictors(add_lonlat=True, apply_pca=True):
    """Stack predictors into a single raster file"""

    n = len(PREDICTORS)

    print("Creating tiff with predictors... ", end="")

    workdir = Path.cwd()

    savepath = workdir / "L2"
    savepath.mkdir(parents=True, exist_ok=True)

    citymask, tf, crs = read_raster(workdir, "citymask_100m.tif")

    X = []
    for pred in PREDICTORS:
        arr, _, _ = read_raster(workdir / "L1", f"{pred}.tif")
        X.append(arr)

    _, height, width = arr.shape

    if add_lonlat:
        # for UTM32N these are x and y coords in m and not the lat/lon coords.
        lons, lats = create_lonlat_grids(tf, width, height)
        lons, lats = lons[np.newaxis, :, :], lats[np.newaxis, :, :]

        lats = robust_scaler(apply_mask(lats, citymask))
        X.append(lats)
        PREDICTORS.append("lat")

        lons = robust_scaler(apply_mask(lons, citymask))
        X.append(lons)
        PREDICTORS.append("lon")

    X = np.concatenate(X, axis=0)
    X = apply_mask(X, citymask)

    if apply_pca:
        pca = PCA()
        X = pca.fit_transform(X.reshape(n + 2, -1).T).T.reshape(n + 2, height, width)
        X = apply_mask(X, citymask)

    gtiff_profile = rio.profiles.DefaultGTiffProfile(
        count=X.shape[0],
        height=height,
        width=width,
        dtype=str(X.dtype),
        crs=crs,
        nodata=FILL_VALUE,
        transform=tf,
    )

    savename = "stacked_predictors.tif"
    with rio.open(savepath / savename, "w", **gtiff_profile) as dst:
        dst.write(X)

    with open(savepath / "predictors_used.json", "w") as f:
        json.dump(
            {"predictors": PREDICTORS, "pca": apply_pca}, f, indent=4, sort_keys=True
        )

    print("Done")


if __name__ == "__main__":
    stack_predictors(add_lonlat=True, apply_pca=True)
